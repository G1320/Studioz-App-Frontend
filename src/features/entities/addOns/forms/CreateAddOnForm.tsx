import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { GenericForm, FieldType } from '@shared/components';
import { useCreateAddOnMutation } from '@shared/hooks';
import { AddOn } from 'src/types/index';
import { useTranslation } from 'react-i18next';
import { toast } from 'sonner';
import AddIcon from '@mui/icons-material/Add';
import CloseIcon from '@mui/icons-material/Close';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import './styles/_create-addon-form.scss';

// Type for pending add-ons (without _id, which will be generated by backend)
export type PendingAddOn = Omit<AddOn, '_id'> & { _id?: string };

interface CreateAddOnFormProps {
  mode?: 'local' | 'immediate';
  onAdd?: (addOn: PendingAddOn) => void;
  onRemove?: (index: number) => void;
  onUpdate?: (index: number, addOn: PendingAddOn) => void;
  pendingAddOns?: PendingAddOn[];
}

export const CreateAddOnForm = ({
  mode = 'immediate',
  onAdd,
  onRemove,
  onUpdate,
  pendingAddOns = []
}: CreateAddOnFormProps = {}) => {
  const { itemId } = useParams();
  const { t } = useTranslation('forms');
  const createAddOnMutation = useCreateAddOnMutation(itemId ? itemId : undefined);
  const [pricePer, setPricePer] = useState<string>('hour');
  const [formKey, setFormKey] = useState<number>(0);
  const [isFormVisible, setIsFormVisible] = useState<boolean>(false);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);

  interface FormData {
    name?: {
      en: string;
      he?: string;
    };
    description?: {
      en: string;
      he?: string;
    };
    price?: number;
    pricePer?: string;
    isActive?: boolean | string;
    imageUrl?: string;
  }

  const pricePerOptions = [
    { value: 'hour', label: t('form.pricePer.hour') },
    { value: 'session', label: t('form.pricePer.session') },
    { value: 'unit', label: t('form.pricePer.unit') },
    { value: 'song', label: t('form.pricePer.song') }
  ];

  const pricePerValues = pricePerOptions.map((option) => option.value);

  const handleSubmit = async (formData: FormData) => {
    // Validate required fields
    if (!formData.name?.en || !formData.price) {
      toast.error('Please fill in all required fields');
      return;
    }

    // Convert string to boolean for isActive (GenericForm passes checkbox values as strings)
    const isActive = formData.isActive === 'true' || formData.isActive === true || formData.isActive === undefined;

    // Get the existing add-on if editing
    const existingAddOn = editingIndex !== null ? pendingAddOns[editingIndex] : null;

    // Create add-on data without _id (will be generated by backend)
    const addOnData: PendingAddOn = {
      name: {
        en: formData.name.en,
        he: formData.name.he || ''
      },
      description: formData.description
        ? {
            en: formData.description.en || '',
            he: formData.description.he || ''
          }
        : undefined,
      price: Number(formData.price),
      pricePer: pricePer as 'hour' | 'session' | 'unit' | 'song',
      itemId: itemId, // Optional - can be undefined when creating addon before item exists
      isActive,
      imageUrl: formData.imageUrl,
      // Preserve _id if editing an existing add-on
      _id: existingAddOn?._id
    };

    // If editing, call onUpdate
    if (editingIndex !== null && onUpdate) {
      onUpdate(editingIndex, addOnData);
      setEditingIndex(null);
      setFormKey((prev) => prev + 1);
      setPricePer('hour');
      setIsFormVisible(false);
      return;
    }

    if (mode === 'local' && onAdd) {
      // Local mode: add to pending list (without _id)
      onAdd(addOnData);
      // Reset form
      setFormKey((prev) => prev + 1);
      setPricePer('hour');
      setIsFormVisible(false);
      toast.success('Add-on added to list');
    } else {
      // Immediate mode: submit to backend (needs _id for type compatibility)
      if (!itemId) {
        toast.error('Item ID is required to create add-on');
        return;
      }
      const addOnForBackend: AddOn = {
        ...addOnData,
        _id: '' // Will be ignored by backend, but needed for type
      };
      createAddOnMutation.mutate(addOnForBackend, {
        onSuccess: () => {
          // Reset form by changing key to force re-render
          setFormKey((prev) => prev + 1);
          setPricePer('hour');
          // Hide form after successful submission
          setIsFormVisible(false);
        }
      });
    }
  };

  const handleEdit = (index: number) => {
    const addOnToEdit = pendingAddOns[index];
    setEditingIndex(index);
    setPricePer(addOnToEdit.pricePer || 'hour');
    setIsFormVisible(true);
    // Reset form key to force re-render with new values
    setFormKey((prev) => prev + 1);
  };

  const handleCancelEdit = () => {
    setEditingIndex(null);
    setPricePer('hour');
    setIsFormVisible(false);
    setFormKey((prev) => prev + 1);
  };

  // Get the add-on being edited for form values
  const editingAddOn = editingIndex !== null ? pendingAddOns[editingIndex] : null;
  // Hide the add-on being edited from the visible list
  const visibleAddOnsCount = Math.max(0, editingIndex !== null ? pendingAddOns.length - 1 : pendingAddOns.length);

  const fields = [
    {
      name: 'name.en',
      label: t('form.name.en'),
      type: 'text' as FieldType,
      value: editingAddOn?.name?.en
    },
    {
      name: 'name.he',
      label: t('form.name.he'),
      type: 'text' as FieldType,
      value: editingAddOn?.name?.he
    },
    {
      name: 'description.en',
      label: t('form.description.en'),
      type: 'textarea' as FieldType,
      value: editingAddOn?.description?.en
    },
    {
      name: 'description.he',
      label: t('form.description.he'),
      type: 'textarea' as FieldType,
      value: editingAddOn?.description?.he
    },
    {
      name: 'price',
      label: t('form.price.label'),
      type: 'number' as FieldType,
      value: editingAddOn?.price
    },
    {
      name: 'pricePer',
      label: t('form.pricePer.label'),
      type: 'select' as FieldType,
      options: pricePerValues,
      value: pricePer,
      onChange: (value: string) => setPricePer(value)
    },
    {
      name: 'isActive',
      label: 'Active',
      type: 'checkbox' as FieldType,
      value: editingAddOn?.isActive ?? true
    }
  ];

  return (
    <section className="create-addon-form-container">
      {/* Show pending add-ons list in local mode */}
      {mode === 'local' && visibleAddOnsCount > 0 && (
        <div className="pending-addons-list">
          <h3>Pending Add-Ons ({visibleAddOnsCount})</h3>
          <div>
            {pendingAddOns.map((addOn, index) =>
              editingIndex === index ? null : (
                <div key={addOn._id || index}>
                  <div>
                    <div>{addOn.name?.en || 'Untitled Add-On'}</div>
                    {addOn.price !== undefined && (
                      <div>
                        ${addOn.price} / {addOn.pricePer || 'hour'}
                      </div>
                    )}
                    {addOn._id && <div style={{ fontSize: '0.8em', color: '#666' }}>Existing</div>}
                  </div>
                  <div>
                    {onUpdate && (
                      <button
                        type="button"
                        onClick={() => handleEdit(index)}
                        title="Edit add-on"
                        aria-label="Edit add-on"
                      >
                        <EditIcon />
                      </button>
                    )}
                    {onRemove && (
                      <button
                        type="button"
                        onClick={() => onRemove(index)}
                        title="Remove add-on"
                        aria-label="Remove add-on"
                      >
                        <DeleteIcon />
                      </button>
                    )}
                  </div>
                </div>
              )
            )}
          </div>
        </div>
      )}

      {!isFormVisible ? (
        <button
          type="button"
          className="add-addon-button"
          onClick={() => setIsFormVisible(true)}
          title={t('form.addAddOn') || 'Add Add-On'}
          aria-label={t('form.addAddOn') || 'Add Add-On'}
        >
          <AddIcon className="add-addon-icon" />
        </button>
      ) : (
        <div className="addon-form-content">
          <div className="create-addon-form-header">
            <h2 className="create-addon-form-title">{editingIndex !== null ? 'Edit Add-On' : 'Add-On'}</h2>
            <button
              type="button"
              className="close-addon-form-button"
              onClick={handleCancelEdit}
              aria-label="Close form"
              title="Close form"
            >
              <CloseIcon />
            </button>
          </div>
          <div className="create-addon-form-wrapper">
            <GenericForm
              key={formKey}
              className="create-addon-form"
              fields={fields}
              onSubmit={handleSubmit}
              btnTxt={
                editingIndex !== null ? t('form.submit.editAddOn') || 'Update Add-On' : t('form.submit.createAddOn')
              }
            />
          </div>
        </div>
      )}
    </section>
  );
};
