import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { GenericForm, FieldType } from '@shared/components';
import { useCreateAddOnMutation } from '@shared/hooks';
import { AddOn } from 'src/types/index';
import { useTranslation } from 'react-i18next';
import { toast } from 'sonner';
import AddIcon from '@mui/icons-material/Add';
import CloseIcon from '@mui/icons-material/Close';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import InventoryIcon from '@mui/icons-material/Inventory';
import './styles/_create-addon-form.scss';

// Type for pending add-ons (without _id, which will be generated by backend)
export type PendingAddOn = Omit<AddOn, '_id'> & { _id?: string };

interface CreateAddOnFormProps {
  mode?: 'local' | 'immediate';
  onAdd?: (addOn: PendingAddOn) => void;
  onRemove?: (index: number) => void;
  onUpdate?: (index: number, addOn: PendingAddOn) => void;
  pendingAddOns?: PendingAddOn[];
}

export const CreateAddOnForm = ({
  mode = 'immediate',
  onAdd,
  onRemove,
  onUpdate,
  pendingAddOns = []
}: CreateAddOnFormProps = {}) => {
  const { itemId } = useParams();
  const { t } = useTranslation('forms');
  const createAddOnMutation = useCreateAddOnMutation(itemId ? itemId : undefined);
  const [pricePer, setPricePer] = useState<string>('hour');
  const [formKey, setFormKey] = useState<number>(0);
  const [isFormVisible, setIsFormVisible] = useState<boolean>(false);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);

  interface FormData {
    name?: {
      en: string;
      he?: string;
    };
    description?: {
      en: string;
      he?: string;
    };
    price?: number;
    pricePer?: string;
    isActive?: boolean | string;
    imageUrl?: string;
  }

  const pricePerOptions = [
    { value: 'hour', label: t('form.pricePer.hour') },
    { value: 'session', label: t('form.pricePer.session') },
    { value: 'unit', label: t('form.pricePer.unit') },
    { value: 'song', label: t('form.pricePer.song') }
  ];

  const pricePerValues = pricePerOptions.map((option) => option.value);

  // Helper to get display label for a value
  const getPricePerLabel = (value: string) => {
    const option = pricePerOptions.find((opt) => opt.value === value);
    return option ? option.label : value;
  };

  const handleSubmit = async (formData: FormData, event?: React.FormEvent<HTMLFormElement>) => {
    // Prevent bubbling into parent item forms
    event?.stopPropagation();
    // Validate required fields
    if (!formData.name?.en || !formData.price) {
      toast.error(t('form.addOn.errors.requiredFields'));
      return;
    }

    // Convert string to boolean for isActive (GenericForm passes checkbox values as strings)
    const isActive = formData.isActive === 'true' || formData.isActive === true || formData.isActive === undefined;

    // Get the existing add-on if editing
    const existingAddOn = editingIndex !== null ? pendingAddOns[editingIndex] : null;

    // Create add-on data without _id (will be generated by backend)
    const addOnData: PendingAddOn = {
      name: {
        en: formData.name.en,
        he: formData.name.he || ''
      },
      description: formData.description
        ? {
            en: formData.description.en || '',
            he: formData.description.he || ''
          }
        : undefined,
      price: Number(formData.price),
      pricePer: pricePer as 'hour' | 'session' | 'unit' | 'song',
      itemId: itemId, // Optional - can be undefined when creating addon before item exists
      isActive,
      imageUrl: formData.imageUrl,
      // Preserve _id if editing an existing add-on
      _id: existingAddOn?._id
    };

    // If editing, call onUpdate
    if (editingIndex !== null && onUpdate) {
      onUpdate(editingIndex, addOnData);
      setEditingIndex(null);
      setFormKey((prev) => prev + 1);
      setPricePer('hour');
      setIsFormVisible(false);
      return;
    }

    if (mode === 'local' && onAdd) {
      // Local mode: add to pending list (without _id)
      onAdd(addOnData);
      // Reset form
      setFormKey((prev) => prev + 1);
      setPricePer('hour');
      setIsFormVisible(false);
      toast.success(t('form.addOn.addedToList'));
    } else {
      // Immediate mode: submit to backend (needs _id for type compatibility)
      if (!itemId) {
        toast.error(t('form.addOn.errors.itemIdRequired'));
        return;
      }
      const addOnForBackend: AddOn = {
        ...addOnData,
        _id: '' // Will be ignored by backend, but needed for type
      };
      createAddOnMutation.mutate(addOnForBackend, {
        onSuccess: () => {
          // Reset form by changing key to force re-render
          setFormKey((prev) => prev + 1);
          setPricePer('hour');
          // Hide form after successful submission
          setIsFormVisible(false);
        }
      });
    }
  };

  const handleEdit = (index: number) => {
    const addOnToEdit = pendingAddOns[index];
    setEditingIndex(index);
    setPricePer(addOnToEdit.pricePer || 'hour');
    setIsFormVisible(true);
    // Reset form key to force re-render with new values
    setFormKey((prev) => prev + 1);
  };

  const handleCancelEdit = () => {
    setEditingIndex(null);
    setPricePer('hour');
    setIsFormVisible(false);
    setFormKey((prev) => prev + 1);
  };

  // Get the add-on being edited for form values
  const editingAddOn = editingIndex !== null ? pendingAddOns[editingIndex] : null;
  // Hide the add-on being edited from the visible list
  const visibleAddOnsCount = Math.max(0, editingIndex !== null ? pendingAddOns.length - 1 : pendingAddOns.length);

  const fields = [
    {
      name: 'name.en',
      label: t('form.name.en'),
      type: 'text' as FieldType,
      value: editingAddOn?.name?.en
    },
    {
      name: 'name.he',
      label: t('form.name.he'),
      type: 'text' as FieldType,
      value: editingAddOn?.name?.he
    },
    {
      name: 'description.en',
      label: t('form.description.en'),
      type: 'textarea' as FieldType,
      value: editingAddOn?.description?.en
    },
    {
      name: 'description.he',
      label: t('form.description.he'),
      type: 'textarea' as FieldType,
      value: editingAddOn?.description?.he
    },
    {
      name: 'price',
      label: t('form.price.label'),
      type: 'number' as FieldType,
      value: editingAddOn?.price
    },
    {
      name: 'pricePer',
      label: t('form.pricePer.label'),
      type: 'select' as FieldType,
      options: pricePerValues,
      value: pricePer,
      displayValue: getPricePerLabel(pricePer),
      getOptionLabel: getPricePerLabel,
      onChange: (value: string) => setPricePer(value)
    },
    {
      name: 'isActive',
      label: t('form.addOn.active'),
      type: 'checkbox' as FieldType,
      value: editingAddOn?.isActive ?? true
    }
  ];

  return (
    <section className="create-addon-form-container">
      {/* Header */}
      <div className="addon-step-header">
        <h2 className="addon-step-title">
          <InventoryIcon className="addon-step-title-icon" />
          {t('form.addOn.stepTitle', { defaultValue: 'Add-ons & Extras' })}
        </h2>
        <p className="addon-step-description">
          {t('form.addOn.stepDescription', { defaultValue: 'Offer extra services or equipment to increase revenue.' })}
        </p>
      </div>

      {/* Show pending add-ons list in local mode */}
      {mode === 'local' && visibleAddOnsCount > 0 && (
        <div className="pending-addons-list">
          <h3>
            {t('form.addOn.pending')} ({visibleAddOnsCount})
          </h3>
          <div>
            {pendingAddOns.map((addOn, index) =>
              editingIndex === index ? null : (
                <div key={addOn._id || index} className="pending-addon-card">
                  <div className="pending-addon-content">
                    <div className="pending-addon-title">{addOn.name?.en || t('form.addOn.untitled')}</div>
                    <div className="pending-addon-type">
                      {addOn.pricePer === 'hour' ? t('form.addOn.perHour', { defaultValue: 'Per Hour' }) : t('form.addOn.flatFee', { defaultValue: 'Flat Fee' })}
                    </div>
                  </div>
                  <div className="pending-addon-actions">
                    {addOn.price !== undefined && (
                      <div className="pending-addon-price">â‚ª{addOn.price}</div>
                    )}
                    {onRemove && (
                      <button
                        type="button"
                        onClick={() => onRemove(index)}
                        title={t('form.addOn.remove')}
                        aria-label={t('form.addOn.remove')}
                      >
                        <DeleteIcon />
                      </button>
                    )}
                  </div>
                </div>
              )
            )}
          </div>
        </div>
      )}

      {!isFormVisible ? (
        <button
          type="button"
          className="add-addon-button"
          onClick={() => setIsFormVisible(true)}
          title={t('form.addOn.addButton')}
          aria-label={t('form.addOn.addButton')}
        >
          <AddIcon className="add-addon-icon" />
          <span className="add-addon-text">{t('form.addOn.createNew', { defaultValue: 'Create New Add-on' })}</span>
        </button>
      ) : (
        <div className="addon-form-content">
          <div className="create-addon-form-header">
            <h2 className="create-addon-form-title">
              {editingIndex !== null ? t('form.addOn.editTitle') : t('form.addOn.newAddOn', { defaultValue: 'New Add-on' })}
            </h2>
            <button
              type="button"
              className="close-addon-form-button"
              onClick={handleCancelEdit}
              aria-label={t('form.addOn.close')}
              title={t('form.addOn.close')}
            >
              <CloseIcon />
            </button>
          </div>
          <div className="create-addon-form-wrapper">
            <GenericForm
              key={formKey}
              className="create-addon-form"
              fields={fields}
              onSubmit={handleSubmit}
              btnTxt={
                editingIndex !== null ? t('form.submit.editAddOn') || 'Update Add-On' : t('form.addOn.addItem', { defaultValue: 'Add Item' })
              }
            />
          </div>
        </div>
      )}
    </section>
  );
};
