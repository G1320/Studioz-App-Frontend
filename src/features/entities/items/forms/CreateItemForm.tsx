import { useState, useMemo, useEffect, useCallback } from 'react';
import { useParams, useSearchParams } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { useQueryClient } from '@tanstack/react-query';
import { SteppedForm, FieldType, FormStep, DurationField, CancellationPolicyField } from '@shared/components';
import type { Duration, CancellationPolicy } from '@shared/components';
import { getLocalUser } from '@shared/services';
import { itemStepSchemas } from '@shared/validation/schemas';
import { getStepFromUrl } from '@shared/components/forms/steppedForm/utils';
import {
  useCreateItemMutation,
  useMusicCategories,
  useMusicSubCategories,
  usePhotoCategories,
  usePhotoSubCategories,
  useStudio,
  useItems,
  useSubscription,
  useCategories
} from '@shared/hooks';
import { Item } from 'src/types/index';
import { CreateAddOnForm, PendingAddOn } from '@features/entities/addOns/forms';
import { isFeatureEnabled } from '@core/config/featureFlags';
import { toast } from 'sonner';
import { createAddOnsBatch } from '@shared/services';
import LocalOfferIcon from '@mui/icons-material/LocalOffer';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import CalendarMonthIcon from '@mui/icons-material/CalendarMonth';
import EventAvailableIcon from '@mui/icons-material/EventAvailable';
import BoltIcon from '@mui/icons-material/Bolt';
import HourglassEmptyIcon from '@mui/icons-material/HourglassEmpty';
import './_createItemForm.scss';

export const CreateItemForm = () => {
  const user = getLocalUser();
  const { studioName, studioId } = useParams();
  const queryClient = useQueryClient();
  const createItemMutation = useCreateItemMutation(studioId || '');
  const { data: studioObj } = useStudio(studioId || '');
  const { data: allItems = [] } = useItems();
  const { hasSubscription, isPro, isStarter, isLoading: isSubscriptionLoading } = useSubscription();
  const { t } = useTranslation(['forms', 'common']);
  const [searchParams] = useSearchParams();
  const [selectedLanguage, setSelectedLanguage] = useState<'en' | 'he'>('en');

  const studio = studioObj?.currStudio;

  // Count user's items
  const userItemCount = useMemo(() => {
    if (!user?._id) return 0;
    return allItems.filter((item) => item.createdBy === user._id).length;
  }, [allItems, user?._id]);

  // Check if user can create more items
  const canCreateItem = useMemo(() => {
    // If subscription is loading, allow (will be validated on submit)
    if (isSubscriptionLoading) return true;

    // If user has paid subscription (pro or starter), allow unlimited
    if (hasSubscription && (isPro || isStarter)) return true;

    // If user has free subscription (no subscription or inactive), limit to 3 items
    return userItemCount < 3;
  }, [hasSubscription, isPro, isStarter, userItemCount, isSubscriptionLoading]);

  const musicCategories = useMusicCategories();
  const musicSubCategories = useMusicSubCategories();
  const photoCategories = usePhotoCategories();
  const photoSubCategories = usePhotoSubCategories();
  const { getEnglishByDisplay } = useCategories();

  const [selectedCategories, setSelectedCategories] = useState<string[]>(musicCategories);
  const [subCategories, setSubCategories] = useState<string[]>(musicSubCategories);
  const [selectedSubCategories, setSelectedSubCategories] = useState<string[]>([musicSubCategories[0]]);
  const [pricePer, setPricePer] = useState<string>('hour'); // Store English value
  const [price, setPrice] = useState<number | undefined>();
  const [blockDiscounts, setBlockDiscounts] = useState<{ eightHour?: number; twelveHour?: number }>({});
  // Pending add-ons without _id (will be generated by backend)
  const [pendingAddOns, setPendingAddOns] = useState<PendingAddOn[]>([]);

  // Booking Settings State
  const [minimumBookingDuration, setMinimumBookingDuration] = useState<Duration>({});
  const [minimumQuantity, setMinimumQuantity] = useState<number | undefined>();
  const [advanceBookingRequired, setAdvanceBookingRequired] = useState<Duration>({});
  const [preparationTime, setPreparationTime] = useState<Duration>({});
  const [instantBook, setInstantBook] = useState<boolean>(false);

  // Policies State
  const [cancellationPolicy, setCancellationPolicy] = useState<CancellationPolicy>({});

  interface FormData {
    coverImage?: string;
    coverAudioFile?: string;
    categories?: string[];
    subCategories?: string[];
    createdBy?: string;
    price?: number;
    pricePer?: string;
    blockDiscounts?: { eightHour?: number; twelveHour?: number };
    studioName?: {
      en: string;
      he?: string;
    };
    studioId?: string;
    address?: string;
    lat?: number;
    lng?: number;
    instantBook?: boolean | string;
    // Booking Settings
    minimumBookingDuration?: Duration;
    minimumQuantity?: number;
    advanceBookingRequired?: Duration;
    preparationTime?: Duration;
    // Policies
    cancellationPolicy?: CancellationPolicy;
  }

  const pricePerOptions = [
    { value: 'hour', label: t('form.pricePer.hour') },
    { value: 'session', label: t('form.pricePer.session') },
    { value: 'unit', label: t('form.pricePer.unit') },
    { value: 'song', label: t('form.pricePer.song') },
    { value: 'project', label: t('form.pricePer.project') },
    { value: 'day', label: t('form.pricePer.day') }
  ];

  // Use English values for options (what gets submitted)
  const pricePerValues = pricePerOptions.map((option) => option.value);

  // Helper to get display label for a value
  const getPricePerLabel = (value: string) => {
    const option = pricePerOptions.find((opt) => opt.value === value);
    return option ? option.label : value;
  };

  const handleCategoryChange = (values: string[]) => {
    setSelectedCategories(values);
    const newSubCategories = values.includes(`${musicCategories}`) ? musicSubCategories : photoSubCategories;
    setSubCategories(newSubCategories);
    setSelectedSubCategories([newSubCategories[0]]);
  };

  const handleSubCategoryChange = (values: string[]) => {
    setSelectedSubCategories(values);
  };

  const handleAddAddOn = useCallback((addOn: PendingAddOn) => {
    setPendingAddOns((prev) => [...prev, addOn]);
  }, []);

  const handleRemoveAddOn = useCallback((index: number) => {
    setPendingAddOns((prev) => prev.filter((_, i) => i !== index));
  }, []);

  // Pricing custom content
  const pricingContent = useMemo(
    () => (
      <div className="pricing-step">
        <div className="pricing-step__header">
          <h2 className="pricing-step__title">
            <LocalOfferIcon className="pricing-step__title-icon" />
            {t('form.pricing.title', { defaultValue: 'Pricing & Rates' })}
          </h2>
          <p className="pricing-step__description">
            {t('form.pricing.description', { defaultValue: 'Set your base rates. You can add special discounts later.' })}
          </p>
        </div>

        <div className="pricing-step__section">
          {/* Pricing Type Radio Buttons */}
          <div className="pricing-step__field pricing-step__field--full">
            <label className="pricing-step__label">
              {t('form.pricing.pricePerLabel', { defaultValue: 'Price per' })}
            </label>
            <div className="pricing-step__radio-group">
              {pricePerOptions.map((option) => (
                <button
                  key={option.value}
                  type="button"
                  onClick={() => setPricePer(option.value)}
                  className={`pricing-step__radio-btn ${pricePer === option.value ? 'pricing-step__radio-btn--active' : ''}`}
                >
                  {option.label}
                </button>
              ))}
            </div>
          </div>

          <div className="pricing-step__grid">
            {/* Price Input */}
            <div className="pricing-step__field">
              <label className="pricing-step__label">
                {t('form.pricing.priceLabel', { defaultValue: 'Price' })}
              </label>
              <div className="pricing-step__input-wrapper">
                <span className="pricing-step__input-prefix">â‚ª</span>
                <input
                  type="number"
                  name="price"
                  placeholder="0.00"
                  value={price ?? ''}
                  onChange={(e) => setPrice(e.target.value ? Number(e.target.value) : undefined)}
                  className="pricing-step__input pricing-step__input--with-prefix pricing-step__input--with-suffix"
                />
                <span className="pricing-step__input-suffix">
                  {t(`form.pricing.per.${pricePer}`, { defaultValue: `/ ${pricePer}` })}
                </span>
              </div>
            </div>

            {/* Minimum Booking Duration - Only show for hourly pricing */}
            {pricePer === 'hour' && (
              <div className="pricing-step__field">
                <label className="pricing-step__label">
                  {t('form.pricing.minimumBooking', { defaultValue: 'Minimum Booking' })}
                </label>
                <div className="pricing-step__input-wrapper">
                  <input
                    type="number"
                    name="minimumBookingDuration"
                    placeholder="1"
                    min={1}
                    value={minimumBookingDuration.value ?? ''}
                    onChange={(e) =>
                      setMinimumBookingDuration({
                        value: e.target.value ? Number(e.target.value) : undefined,
                        unit: 'hours'
                      })
                    }
                    className="pricing-step__input pricing-step__input--with-suffix"
                  />
                  <span className="pricing-step__input-suffix">
                    {t('form.pricing.hours', { defaultValue: 'hours' })}
                  </span>
                </div>
              </div>
            )}
          </div>

          {/* Block Discounts - Only show for hourly pricing */}
          {pricePer === 'hour' && (
            <div className="pricing-step__block-discounts">
              <div className="pricing-step__block-discounts-header">
                <LocalOfferIcon className="pricing-step__block-discounts-icon" />
                <span className="pricing-step__block-discounts-title">
                  {t('form.pricing.blockDiscounts.title', { defaultValue: 'Block Discounts (Optional)' })}
                </span>
              </div>
              <div className="pricing-step__grid">
                <div className="pricing-step__field">
                  <label className="pricing-step__label">
                    {t('form.pricing.blockDiscounts.eightHour', { defaultValue: '8 Hour Block Price' })}
                  </label>
                  <div className="pricing-step__input-wrapper">
                    <span className="pricing-step__input-prefix">â‚ª</span>
                    <input
                      type="number"
                      placeholder={t('form.pricing.blockDiscounts.placeholder', { defaultValue: 'Discounted total' })}
                      value={blockDiscounts.eightHour ?? ''}
                      onChange={(e) =>
                        setBlockDiscounts((prev) => ({
                          ...prev,
                          eightHour: e.target.value ? Number(e.target.value) : undefined
                        }))
                      }
                      className="pricing-step__input pricing-step__input--with-prefix pricing-step__input--with-suffix"
                    />
                    <span className="pricing-step__input-suffix">
                      {t('form.pricing.blockDiscounts.total', { defaultValue: 'total' })}
                    </span>
                  </div>
                </div>
                <div className="pricing-step__field">
                  <label className="pricing-step__label">
                    {t('form.pricing.blockDiscounts.twelveHour', { defaultValue: '12 Hour Block Price' })}
                  </label>
                  <div className="pricing-step__input-wrapper">
                    <span className="pricing-step__input-prefix">â‚ª</span>
                    <input
                      type="number"
                      placeholder={t('form.pricing.blockDiscounts.placeholder', { defaultValue: 'Discounted total' })}
                      value={blockDiscounts.twelveHour ?? ''}
                      onChange={(e) =>
                        setBlockDiscounts((prev) => ({
                          ...prev,
                          twelveHour: e.target.value ? Number(e.target.value) : undefined
                        }))
                      }
                      className="pricing-step__input pricing-step__input--with-prefix pricing-step__input--with-suffix"
                    />
                    <span className="pricing-step__input-suffix">
                      {t('form.pricing.blockDiscounts.total', { defaultValue: 'total' })}
                    </span>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Commission Info Note */}
        <div className="pricing-step__info-box">
          <InfoOutlinedIcon className="pricing-step__info-icon" />
          <div className="pricing-step__info-content">
            <h4 className="pricing-step__info-title">
              {t('form.pricing.platformFee.title', { defaultValue: 'Platform Fee' })}
            </h4>
            <p className="pricing-step__info-text">
              {t('form.pricing.platformFee.description', {
                defaultValue:
                  'StudioZ takes a 10% commission on confirmed bookings. Your payout will be calculated automatically.'
              })}
            </p>
          </div>
        </div>
      </div>
    ),
    [t, pricePer, price, blockDiscounts, pricePerOptions, minimumBookingDuration]
  );

  // Booking Settings custom content
  const bookingSettingsContent = useMemo(
    () => (
      <div className="booking-settings-step">
        <div className="booking-settings-step__header">
          <h2 className="booking-settings-step__title">
            <CalendarMonthIcon className="booking-settings-step__title-icon" />
            {t('form.bookingSettings.title', { defaultValue: 'Booking Settings' })}
          </h2>
          <p className="booking-settings-step__description">
            {t('form.bookingSettings.subtitle', { defaultValue: 'Control how users book your space and manage your schedule.' })}
          </p>
        </div>

        {/* Booking Mode Selection */}
        <div className="booking-settings-step__mode-grid">
          <button
            type="button"
            onClick={() => setInstantBook(false)}
            className={`booking-settings-step__mode-card ${!instantBook ? 'booking-settings-step__mode-card--active' : ''}`}
          >
            <div className={`booking-settings-step__mode-icon ${!instantBook ? 'booking-settings-step__mode-icon--active' : 'booking-settings-step__mode-icon--default'}`}>
              <EventAvailableIcon />
            </div>
            <h3 className={`booking-settings-step__mode-title ${!instantBook ? 'booking-settings-step__mode-title--active' : 'booking-settings-step__mode-title--default'}`}>
              {t('form.bookingSettings.requestToBook.title', { defaultValue: 'Request to Book' })}
            </h3>
            <p className="booking-settings-step__mode-description">
              {t('form.bookingSettings.requestToBook.description', { defaultValue: 'Review every booking request before accepting. Best for studios that need to screen clients.' })}
            </p>
          </button>

          <button
            type="button"
            onClick={() => setInstantBook(true)}
            className={`booking-settings-step__mode-card ${instantBook ? 'booking-settings-step__mode-card--active' : ''}`}
          >
            <div className={`booking-settings-step__mode-icon ${instantBook ? 'booking-settings-step__mode-icon--active' : 'booking-settings-step__mode-icon--default'}`}>
              <BoltIcon />
            </div>
            <h3 className={`booking-settings-step__mode-title ${instantBook ? 'booking-settings-step__mode-title--active' : 'booking-settings-step__mode-title--default'}`}>
              {t('form.bookingSettings.instantBook.title', { defaultValue: 'Instant Book' })}
            </h3>
            <p className="booking-settings-step__mode-description">
              {t('form.bookingSettings.instantBook.description', { defaultValue: 'Allow users to book instantly without approval. Gets 2x more bookings on average.' })}
            </p>
          </button>
        </div>

        {/* Settings Dropdowns */}
        <div className="booking-settings-step__settings-grid">
          <div className="booking-settings-step__field">
            <label className="booking-settings-step__label">
              {t('form.bookingSettings.advanceNotice.label', { defaultValue: 'Advance Notice' })}
              <HourglassEmptyIcon />
            </label>
            <div className="booking-settings-step__select-wrapper">
              <select
                className="booking-settings-step__select"
                value={advanceBookingRequired.value && advanceBookingRequired.unit ? `${advanceBookingRequired.value}-${advanceBookingRequired.unit}` : '1-hours'}
                onChange={(e) => {
                  const [value, unit] = e.target.value.split('-');
                  setAdvanceBookingRequired({ value: parseInt(value), unit: unit as 'hours' | 'days' });
                }}
              >
                <option value="1-hours">{t('form.bookingSettings.advanceNotice.options.1hour', { defaultValue: 'At least 1 hour in advance' })}</option>
                <option value="24-hours">{t('form.bookingSettings.advanceNotice.options.24hours', { defaultValue: 'At least 24 hours in advance' })}</option>
                <option value="48-hours">{t('form.bookingSettings.advanceNotice.options.48hours', { defaultValue: 'At least 48 hours in advance' })}</option>
                <option value="3-days">{t('form.bookingSettings.advanceNotice.options.3days', { defaultValue: 'At least 3 days in advance' })}</option>
              </select>
              <span className="booking-settings-step__select-arrow">â–¼</span>
            </div>
          </div>

          <div className="booking-settings-step__field">
            <label className="booking-settings-step__label">
              {t('form.bookingSettings.preparationTime.label', { defaultValue: 'Preparation Time (Buffer)' })}
            </label>
            <div className="booking-settings-step__select-wrapper">
              <select
                className="booking-settings-step__select"
                value={preparationTime.value && preparationTime.unit ? `${preparationTime.value}-${preparationTime.unit}` : '0'}
                onChange={(e) => {
                  if (e.target.value === '0') {
                    setPreparationTime({});
                  } else {
                    const [value, unit] = e.target.value.split('-');
                    setPreparationTime({ value: parseInt(value), unit: unit as 'minutes' | 'hours' });
                  }
                }}
              >
                <option value="0">{t('form.bookingSettings.preparationTime.options.none', { defaultValue: 'None' })}</option>
                <option value="15-minutes">{t('form.bookingSettings.preparationTime.options.15min', { defaultValue: '15 minutes' })}</option>
                <option value="30-minutes">{t('form.bookingSettings.preparationTime.options.30min', { defaultValue: '30 minutes' })}</option>
                <option value="60-minutes">{t('form.bookingSettings.preparationTime.options.1hour', { defaultValue: '1 hour' })}</option>
              </select>
              <span className="booking-settings-step__select-arrow">â–¼</span>
            </div>
          </div>
        </div>

        {/* Minimum Quantity - only for non-hourly pricing */}
        {pricePer !== 'hour' && (
          <div className="booking-settings-step__field">
            <label className="booking-settings-step__label">
              {t('form.bookingSettings.minimumQuantity.label')}
            </label>
            <input
              type="number"
              name="minimumQuantity"
              value={minimumQuantity ?? ''}
              onChange={(e) => setMinimumQuantity(e.target.value ? Number(e.target.value) : undefined)}
              min={1}
              placeholder="1"
              className="booking-settings-step__input"
            />
          </div>
        )}
      </div>
    ),
    [
      t,
      pricePer,
      minimumQuantity,
      advanceBookingRequired,
      preparationTime,
      instantBook
    ]
  );

  // Policies custom content
  const policiesContent = useMemo(
    () => (
      <div className="policies-step">
        <CancellationPolicyField value={cancellationPolicy} onChange={setCancellationPolicy} />
      </div>
    ),
    [cancellationPolicy]
  );

  // Define form steps with Zod schemas
  const steps: FormStep[] = useMemo(
    () => [
      {
        id: 'basic-info',
        title: t('form.steps.basicInfo') || 'Basic Information',
        description: t('form.steps.basicInfoDesc') || 'Enter your item name and description',
        fieldNames: ['name.en', 'name.he', 'description.en', 'description.he', 'languageToggle'],
        schema: itemStepSchemas['basic-info'],
        languageToggle: true
      },
      {
        id: 'categories',
        title: t('form.steps.categories') || 'Categories',
        description: t('form.steps.categoriesDesc') || 'Select categories and subcategories',
        fieldNames: ['categories', 'subCategories'],
        schema: itemStepSchemas.categories
      },
      {
        id: 'pricing',
        title: t('form.steps.pricing') || 'Pricing & Options',
        description: t('form.steps.pricingDesc') || 'Set price and booking options',
        fieldNames: ['price', 'pricePer', 'blockDiscounts', 'minimumBookingDuration'],
        schema: itemStepSchemas.pricing,
        customContent: pricingContent
      },
      {
        id: 'booking-settings',
        title: t('form.steps.bookingSettings') || 'Booking Settings',
        description: t('form.steps.bookingSettingsDesc') || 'Set booking rules and preparation times',
        fieldNames: [
          'minimumQuantity',
          'advanceBookingRequired',
          'preparationTime'
        ],
        schema: itemStepSchemas['booking-settings'],
        customContent: bookingSettingsContent
      },
      {
        id: 'policies',
        title: t('form.steps.policies') || 'Policies',
        description: t('form.steps.policiesDesc') || 'Define cancellation and booking policies',
        fieldNames: ['cancellationPolicy'],
        schema: itemStepSchemas.policies,
        customContent: policiesContent
      },
      ...(isFeatureEnabled('addOns')
        ? [
            {
              id: 'add-ons',
              title: t('form.steps.addOns') || 'Add-Ons',
              description: t('form.steps.addOnsDesc') || 'Add optional add-ons to your item',
              fieldNames: [],
              schema: itemStepSchemas['add-ons'],
              customContent: (
                <CreateAddOnForm
                  mode="local"
                  onAdd={handleAddAddOn}
                  onRemove={handleRemoveAddOn}
                  pendingAddOns={pendingAddOns}
                />
              )
            }
          ]
        : [])
    ],
    [t, pendingAddOns, handleAddAddOn, handleRemoveAddOn, pricingContent, bookingSettingsContent, policiesContent]
  );

  // Initialize currentStepIndex from URL on mount (after steps are defined)
  const [currentStepIndex, setCurrentStepIndex] = useState(0);

  // Initialize and sync currentStepIndex with URL
  useEffect(() => {
    const urlStepIndex = getStepFromUrl(searchParams, steps);
    setCurrentStepIndex(urlStepIndex);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  // Reset language when step changes
  useEffect(() => {
    setSelectedLanguage('en');
  }, [currentStepIndex]);

  const handleSubmit = async (formData: FormData) => {
    // Check subscription limit before submitting
    if (!canCreateItem) {
      toast.error(
        t('form.errors.itemLimitReached', {
          defaultValue:
            'You have reached the maximum limit of 3 services for free accounts. Please upgrade to a paid plan to create more services.'
        })
      );
      return;
    }

    // Convert subCategories to English values for consistent database storage
    const englishSubCategories = selectedSubCategories.map((subCat) => getEnglishByDisplay(subCat));

    formData.createdBy = user?._id || '';
    formData.categories = selectedCategories;
    formData.subCategories = englishSubCategories;
    formData.studioName = {
      en: studioName || ''
    };
    formData.studioId = studioId || '';
    formData.address = studio?.address || '';
    formData.lat = studio?.lat || 0;
    formData.lng = studio?.lng || 0;
    // pricePer is already in English ('hour', 'session', etc.)
    formData.pricePer = pricePer;
    // Use the state value for price
    formData.price = price;
    // Add block discounts if set
    if (blockDiscounts.eightHour || blockDiscounts.twelveHour) {
      formData.blockDiscounts = blockDiscounts;
    }
    // Use the state value for instantBook
    formData.instantBook = instantBook;

    // Add booking settings (only include if they have values)
    if (minimumBookingDuration.value && minimumBookingDuration.unit) {
      formData.minimumBookingDuration = minimumBookingDuration;
    }
    if (minimumQuantity !== undefined && minimumQuantity > 0) {
      formData.minimumQuantity = minimumQuantity;
    }
    if (advanceBookingRequired.value && advanceBookingRequired.unit) {
      formData.advanceBookingRequired = advanceBookingRequired;
    }
    if (preparationTime.value && preparationTime.unit) {
      formData.preparationTime = preparationTime;
    }

    // Add cancellation policy (only include if type is selected)
    if (cancellationPolicy.type) {
      formData.cancellationPolicy = cancellationPolicy;
    }

    // Remove UI-only fields that shouldn't be sent to the API
    // delete formData.languageToggle;

    // Create item first, then batch create add-ons
    createItemMutation.mutate(formData as Item, {
      onSuccess: async (createdItem) => {
        // Batch create add-ons if any are pending
        if (pendingAddOns.length > 0) {
          try {
            await createAddOnsBatch(createdItem._id, pendingAddOns);
            toast.success(t('common:toasts.success.itemWithAddOns', { count: pendingAddOns.length }));
            setPendingAddOns([]); // Clear pending add-ons
          } catch (error) {
            console.error('Error creating add-ons:', error);
            toast.error(t('common:toasts.error.itemCreatedAddOnsFailed'));
          }
        }
        // Invalidate addOns queries
        await queryClient.invalidateQueries({ queryKey: ['addOns', 'item', createdItem._id] });
        await queryClient.invalidateQueries({ queryKey: ['addOns'] });
      }
    });
  };

  const fields = [
    {
      name: 'name.en',
      label: `${t('form.name.en')} ðŸ‡ºðŸ‡¸`,
      type: 'text' as FieldType,
      placeholder: t('form.name.placeholder', { defaultValue: 'e.g. The Sound Garden' }),
      helperText: t('form.name.helperText')
    },
    {
      name: 'name.he',
      label: `${t('form.name.he')} ðŸ‡®ðŸ‡±`,
      type: 'text' as FieldType,
      placeholder: t('form.name.placeholderHe', { defaultValue: '×œ×“×•×’×ž×”: ×’×Ÿ ×”×¦×œ×™×œ×™×' }),
      helperText: t('form.name.helperText')
    },
    {
      name: 'description.en',
      label: `${t('form.description.en')} ðŸ‡ºðŸ‡¸`,
      type: 'textarea' as FieldType,
      placeholder: t('form.description.placeholder', { defaultValue: "Describe your studio's vibe, equipment, and what makes it unique..." }),
      helperText: t('form.description.helperText')
    },
    {
      name: 'description.he',
      label: `${t('form.description.he')} ðŸ‡®ðŸ‡±`,
      type: 'textarea' as FieldType,
      placeholder: t('form.description.placeholderHe', { defaultValue: '×ª××¨×• ××ª ×”××•×•×™×¨×”, ×”×¦×™×•×“ ×•×ž×” ×©×ž×™×™×—×“ ××ª ×”×¡×˜×•×“×™×• ×©×œ×›×...' }),
      helperText: t('form.description.helperText')
    },
    {
      name: 'languageToggle',
      label: t('form.languageToggle.label') || 'Select language for editing',
      type: 'languageToggle' as FieldType,
      value: selectedLanguage,
      onChange: setSelectedLanguage
    },
    {
      name: 'categories',
      label: t('form.categories.label'),
      type: 'select' as FieldType,
      options: [musicCategories, photoCategories],
      value: selectedCategories,
      onChange: handleCategoryChange
    },
    {
      name: 'subCategories',
      label: t('form.subCategories.label') || 'Sub Categories',
      type: 'multiSelect' as FieldType,
      options: subCategories,
      value: selectedSubCategories,
      onChange: handleSubCategoryChange,
      initialVisibleCount: 12,
      showAllLabel: t('form.subCategories.showAll', 'Show All'),
      showLessLabel: t('form.subCategories.showLess', 'Show Less'),
      className: 'subcategories-plain',
      helperText: t('form.subCategories.helperText')
    },
    {
      name: 'price',
      label: t('form.price.label'),
      type: 'number' as FieldType,
      helperText: t('form.price.helperText')
    },
    {
      name: 'pricePer',
      label: t('form.pricePer.label'),
      type: 'select' as FieldType,
      options: pricePerValues,
      value: pricePer,
      displayValue: getPricePerLabel(pricePer),
      getOptionLabel: getPricePerLabel,
      onChange: (value: string) => setPricePer(value)
    }
  ];

  // Calculate remaining items for free users
  const remainingItems = useMemo(() => {
    if (isSubscriptionLoading) return null;
    if (hasSubscription && (isPro || isStarter)) return null; // Unlimited for paid users
    return Math.max(0, 3 - userItemCount);
  }, [hasSubscription, isPro, isStarter, userItemCount, isSubscriptionLoading]);

  return (
    <section>
      <h1>{t('form.AddItemTitle')}</h1>
      {remainingItems !== null && (
        <div
          style={{
            padding: '12px 16px',
            marginBottom: '16px',
            backgroundColor: remainingItems === 0 ? 'rgba(248, 113, 113, 0.2)' : 'rgba(16, 185, 129, 0.1)',
            border: `1px solid ${remainingItems === 0 ? 'rgba(248, 113, 113, 0.3)' : 'rgba(16, 185, 129, 0.3)'}`,
            borderRadius: '8px',
            color: remainingItems === 0 ? '#f87171' : '#10b981'
          }}
        >
          {remainingItems === 0 ? (
            <p style={{ margin: 0, fontWeight: 600 }}>
              {t('form.errors.itemLimitReached', {
                defaultValue:
                  'You have reached the maximum limit of 3 items. Please upgrade to a paid plan to create more items.'
              })}
            </p>
          ) : (
            <p style={{ margin: 0, fontWeight: 500 }}>
              {t('form.itemLimitInfo', {
                defaultValue: `You have ${remainingItems} item${remainingItems !== 1 ? 's' : ''} remaining on your free plan. Upgrade to create unlimited items.`,
                count: remainingItems
              })}
            </p>
          )}
        </div>
      )}
      <section className="form-wrapper create-item-form-wrapper">
        <SteppedForm
          className="create-item-form"
          formId="create-item-form"
          steps={steps}
          fields={fields}
          onSubmit={handleSubmit}
          submitButtonText={t('form.submit.createItem')}
          nextButtonText={t('form.buttons.next') || 'Next'}
          previousButtonText={t('form.buttons.previous') || 'Previous'}
          selectedLanguage={selectedLanguage}
          onLanguageChange={setSelectedLanguage}
          onStepChange={(current) => setCurrentStepIndex(current)}
        />
      </section>
    </section>
  );
};
