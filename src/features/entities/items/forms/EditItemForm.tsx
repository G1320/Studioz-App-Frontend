import { useState, useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { useQueryClient } from '@tanstack/react-query';
import { FileUploader, GenericForm, FieldType } from '@shared/components';
import {
  useItem,
  useMusicCategories,
  useMusicSubCategories,
  usePhotoCategories,
  usePhotoSubCategories,
  useUpdateItemMutation,
  useAddOns,
  useDeleteAddOnMutation
} from '@shared/hooks';
import { uploadFile, createAddOnsBatch, updateAddOn } from '@shared/services';
import { Item } from 'src/types/index';
import { toast } from 'sonner';
import { arraysEqual } from '@shared/utils/compareArrays';
import { CreateAddOnForm, PendingAddOn } from '@features/entities/addOns/forms';
import { isFeatureEnabled } from '@core/config/featureFlags';

interface FormData {
  imageUrl?: string;
  categories?: string[];
  subCategories?: string[];
  studioId?: string;
  pricePer?: string;
  instantBook?: boolean | string;
}

export const EditItemForm = () => {
  const { itemId } = useParams();
  const { data: item } = useItem(itemId || '');
  const { data: existingAddOns = [] } = useAddOns(itemId);
  const { t } = useTranslation('forms');
  const hasPopulatedAddOns = useRef(false);

  const musicCategories = useMusicCategories();
  const musicSubCategories = useMusicSubCategories();
  const photoCategories = usePhotoCategories();
  const photoSubCategories = usePhotoSubCategories();

  const updateItemMutation = useUpdateItemMutation(itemId || '');
  const deleteAddOnMutation = useDeleteAddOnMutation();
  const queryClient = useQueryClient();

  const [selectedCategories, setSelectedCategories] = useState<string[]>(
    item?.categories && item.categories.length > 0 ? [item.categories[0]] : musicCategories
  );
  const [selectedSubCategories, setSelectedSubCategories] = useState<string[]>(item?.subCategories || []);
  const [subCategories, setSubCategories] = useState<string[]>(musicSubCategories);
  const [imageUrl, setImageUrl] = useState<string>(item?.imageUrl || '');
  const [pricePer, setPricePer] = useState<string>('hour');
  // Pending add-ons without _id (will be generated by backend)
  const [pendingAddOns, setPendingAddOns] = useState<PendingAddOn[]>([]);

  // Populate pending add-ons with existing add-ons when they're loaded
  useEffect(() => {
    if (existingAddOns.length > 0 && !hasPopulatedAddOns.current) {
      // Convert AddOn[] to PendingAddOn[] (keeping _id since it's optional in PendingAddOn)
      const pendingAddOnsFromExisting: PendingAddOn[] = existingAddOns.map((addOn) => ({
        ...addOn,
        _id: addOn._id // Keep the _id so we know these are existing add-ons
      }));
      setPendingAddOns(pendingAddOnsFromExisting);
      hasPopulatedAddOns.current = true;
    }
  }, [existingAddOns]);

  const handleCategoryChange = (values: string[]) => {
    setSelectedCategories(values);
    const newSubCategories = values.includes(`${musicCategories}`) ? musicSubCategories : photoSubCategories;
    setSubCategories(newSubCategories);
    setSelectedSubCategories([newSubCategories[0]]);
  };

  const handleSubCategoryChange = (values: string[]) => {
    setSelectedSubCategories(values);
  };

  const handleAddAddOn = (addOn: PendingAddOn) => {
    setPendingAddOns((prev) => [...prev, addOn]);
  };

  const handleRemoveAddOn = (index: number) => {
    const addOnToRemove = pendingAddOns[index];

    // If it's an existing add-on (has _id), delete it from backend
    if (addOnToRemove._id) {
      deleteAddOnMutation.mutate(addOnToRemove._id, {
        onSuccess: () => {
          // Remove from local state after successful deletion
          setPendingAddOns((prev) => prev.filter((_, i) => i !== index));
          toast.success('Add-on deleted successfully');
        },
        onError: (error) => {
          console.error('Error deleting add-on:', error);
          toast.error('Failed to delete add-on');
        }
      });
    } else {
      // If it's a new add-on (no _id), just remove from local state
      setPendingAddOns((prev) => prev.filter((_, i) => i !== index));
    }
  };

  const handleUpdateAddOn = async (index: number, updatedAddOn: PendingAddOn) => {
    const existingAddOn = pendingAddOns[index];

    // If it's an existing add-on (has _id), update it in backend
    if (existingAddOn._id && updatedAddOn._id) {
      try {
        await updateAddOn(existingAddOn._id, updatedAddOn as any);
        // Update local state after successful update
        setPendingAddOns((prev) => prev.map((addOn, i) => (i === index ? updatedAddOn : addOn)));

        // Invalidate queries to refresh data
        await queryClient.invalidateQueries({ queryKey: ['addOn', existingAddOn._id] });
        await queryClient.invalidateQueries({ queryKey: ['addOns'] });
        if (itemId) {
          await queryClient.invalidateQueries({ queryKey: ['addOns', 'item', itemId] });
          await queryClient.invalidateQueries({ queryKey: ['item', itemId] });
          await queryClient.invalidateQueries({ queryKey: ['items', {}] });
        }

        toast.success('Add-on updated successfully');
      } catch (error) {
        console.error('Error updating add-on:', error);
        toast.error('Failed to update add-on');
      }
    } else {
      // If it's a new add-on, just update local state
      setPendingAddOns((prev) => prev.map((addOn, i) => (i === index ? updatedAddOn : addOn)));
    }
  };

  const pricePerOptions = [
    { value: 'hour', label: t('common.items.price_per.hour') },
    { value: 'session', label: t('common.items.price_per.session') },
    { value: 'unit', label: t('common.items.price_per.unit') },
    { value: 'song', label: t('common.items.price_per.song') }
  ];

  const pricePerValues = pricePerOptions.map((option) => option.value);

  const fields = [
    { name: 'name.en', label: 'English Name', type: 'text' as FieldType, value: item?.name.en },
    { name: 'name.he', label: 'Hebrew Name', type: 'text' as FieldType, value: item?.name.he },
    {
      name: 'description.en',
      label: 'English Description',
      type: 'textarea' as FieldType,
      value: item?.description?.en
    },
    {
      name: 'description.he',
      label: 'Hebrew Description',
      type: 'textarea' as FieldType,
      value: item?.description?.he
    },
    {
      name: 'categories',
      label: 'Category',
      type: 'select' as FieldType,
      options: [musicCategories, photoCategories],
      value: selectedCategories,
      onChange: handleCategoryChange
    },
    {
      name: 'subCategories',
      label: arraysEqual(selectedCategories, musicCategories) ? [musicCategories] : [photoCategories],
      type: 'multiSelect' as FieldType,
      options: subCategories,
      value: selectedSubCategories,
      onChange: handleSubCategoryChange
    },
    { name: 'price', label: 'Price', type: 'number' as FieldType, value: item?.price },
    {
      name: 'pricePer',
      label: 'Price Per',
      type: 'select' as FieldType,
      options: pricePerValues,
      value: pricePer,
      onChange: (value: string) => setPricePer(value)
    },
    {
      name: 'instantBook',
      label: t('forms:form.instantBook.label'),
      type: 'checkbox' as FieldType,
      value: item?.instantBook || false
    }
  ];

  const handleSubmit = async (formData: FormData) => {
    formData.imageUrl = imageUrl;
    formData.categories = selectedCategories;
    formData.subCategories = selectedSubCategories;
    formData.studioId = item?.studioId || '';
    formData.pricePer = pricePer;
    // Convert string to boolean for instantBook (GenericForm passes checkbox values as strings)
    formData.instantBook = formData.instantBook === 'true' || formData.instantBook === true;

    // Update item first, then batch create new add-ons (only ones without _id)
    updateItemMutation.mutate(formData as Item, {
      onSuccess: async () => {
        // Filter to only new add-ons (without _id) for batch creation
        const newAddOns = pendingAddOns.filter((addOn) => !addOn._id);

        if (newAddOns.length > 0 && itemId) {
          try {
            await createAddOnsBatch(itemId, newAddOns);
            toast.success(`Item updated and ${newAddOns.length} add-on(s) created successfully`);
            // Remove created add-ons from pending list, keep existing ones
            setPendingAddOns((prev) => prev.filter((addOn) => addOn._id));
          } catch (error) {
            console.error('Error creating add-ons:', error);
            toast.error('Item updated but failed to create some add-ons. Please add them manually.');
          }
        } else if (pendingAddOns.length > 0) {
          // All add-ons are existing ones, just show success
          toast.success('Item updated successfully');
        }
        // Invalidate addOns queries
        if (itemId) {
          await queryClient.invalidateQueries({ queryKey: ['addOns', 'item', itemId] });
        }
        await queryClient.invalidateQueries({ queryKey: ['addOns'] });
      }
    });
  };

  const handleFileUpload = async (files: File[], type: string) => {
    const results = await Promise.all(files.map((file) => uploadFile(file)));
    const urls = results.map((result) => result.secure_url);

    if (type === 'image') {
      if (files.length === 1) {
        setImageUrl(urls[0]);
        return toast.success('Image uploaded successfully');
      }
      toast.success('Gallery images uploaded successfully');
    }
  };

  return (
    <section>
      <FileUploader fileType="image" onFileUpload={handleFileUpload} isCoverShown={true} />
      <section className="form-wrapper edit-item-form-wrapper">
        <GenericForm
          className="edit-item-form"
          title="Edit Item"
          fields={fields}
          onSubmit={handleSubmit}
          onCategoryChange={handleCategoryChange}
          btnTxt={t('form.submit.editItem')}
          formId="edit-item-form"
          hideSubmit
        />
      </section>
      {isFeatureEnabled('addOns') && (
        <section className="addon-form-section">
          <CreateAddOnForm
            mode="local"
            onAdd={handleAddAddOn}
            onRemove={handleRemoveAddOn}
            onUpdate={handleUpdateAddOn}
            pendingAddOns={pendingAddOns}
          />
        </section>
      )}
      <div className="form-actions">
        <button form="edit-item-form" type="submit" className="submit-button">
          {t('form.submit.editItem')}
        </button>
      </div>
    </section>
  );
};
