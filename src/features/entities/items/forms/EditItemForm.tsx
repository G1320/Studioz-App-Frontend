import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useParams, useSearchParams } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { useQueryClient } from '@tanstack/react-query';
import { SteppedForm, FieldType, FormStep, DurationField, CancellationPolicyField } from '@shared/components';
import type { Duration, CancellationPolicy } from '@shared/components';
import { itemStepSchemasEdit } from '@shared/validation/schemas';
import { getStepFromUrl } from '@shared/components/forms/steppedForm/utils';
import {
  useItem,
  useMusicCategories,
  useMusicSubCategories,
  usePhotoCategories,
  usePhotoSubCategories,
  useUpdateItemMutation,
  useAddOns,
  useDeleteAddOnMutation,
  useStudio
} from '@shared/hooks';
import { createAddOnsBatch, updateAddOn } from '@shared/services';
import { Item } from 'src/types/index';
import { toast } from 'sonner';
import { CreateAddOnForm, PendingAddOn } from '@features/entities/addOns/forms';
import { isFeatureEnabled } from '@core/config/featureFlags';
import { Switch, Field, Label } from '@headlessui/react';
import './_createItemForm.scss';

interface ItemFormData {
  imageUrl?: string;
  categories?: string[];
  subCategories?: string[];
  studioId?: string;
  pricePer?: string;
  instantBook?: boolean | string;
  city?: string;
  languageToggle?: string;
  // Booking Settings
  minimumBookingDuration?: Duration;
  maximumBookingDuration?: Duration;
  minimumQuantity?: number;
  advanceBookingRequired?: Duration;
  preparationTime?: Duration;
  bufferTime?: Duration;
  allowSameDayBooking?: boolean;
  // Policies
  cancellationPolicy?: CancellationPolicy;
  [key: string]: any; // Allow additional properties from form
}

export const EditItemForm = () => {
  const { itemId } = useParams();
  const { data: item } = useItem(itemId || '');
  const { data: studioData } = useStudio(item?.studioId || '');
  const studio = studioData?.currStudio;
  const { data: existingAddOns = [] } = useAddOns(itemId);
  const { t } = useTranslation('forms');
  const [searchParams] = useSearchParams();
  const [selectedLanguage, setSelectedLanguage] = useState<'en' | 'he'>('en');
  const hasPopulatedAddOns = useRef(false);

  const musicCategories = useMusicCategories();
  const musicSubCategories = useMusicSubCategories();
  const photoCategories = usePhotoCategories();
  const photoSubCategories = usePhotoSubCategories();

  const updateItemMutation = useUpdateItemMutation(itemId || '');
  const deleteAddOnMutation = useDeleteAddOnMutation();
  const queryClient = useQueryClient();

  const [selectedCategories, setSelectedCategories] = useState<string[]>(
    item?.categories && item.categories.length > 0 ? [item.categories[0]] : musicCategories
  );
  const [selectedSubCategories, setSelectedSubCategories] = useState<string[]>(item?.subCategories || []);
  const [subCategories, setSubCategories] = useState<string[]>(musicSubCategories);
  const [imageUrl] = useState<string>(item?.imageUrl || '');
  const [pricePer, setPricePer] = useState<string>(item?.pricePer || 'hour');
  // Pending add-ons without _id (will be generated by backend)
  const [pendingAddOns, setPendingAddOns] = useState<PendingAddOn[]>([]);

  // Booking Settings State - Initialize from item data
  const [minimumBookingDuration, setMinimumBookingDuration] = useState<Duration>(
    item?.minimumBookingDuration || {}
  );
  const [maximumBookingDuration, setMaximumBookingDuration] = useState<Duration>(
    item?.maximumBookingDuration || {}
  );
  const [minimumQuantity, setMinimumQuantity] = useState<number | undefined>(
    item?.minimumQuantity
  );
  const [advanceBookingRequired, setAdvanceBookingRequired] = useState<Duration>(
    item?.advanceBookingRequired || {}
  );
  const [preparationTime, setPreparationTime] = useState<Duration>(
    item?.preparationTime || {}
  );
  const [bufferTime, setBufferTime] = useState<Duration>(
    item?.bufferTime || {}
  );
  const [allowSameDayBooking, setAllowSameDayBooking] = useState<boolean>(
    item?.allowSameDayBooking || false
  );

  // Policies State
  const [cancellationPolicy, setCancellationPolicy] = useState<CancellationPolicy>(
    item?.cancellationPolicy || {}
  );

  // Populate pending add-ons with existing add-ons when they're loaded
  useEffect(() => {
    if (existingAddOns.length > 0 && !hasPopulatedAddOns.current) {
      // Convert AddOn[] to PendingAddOn[] (keeping _id since it's optional in PendingAddOn)
      const pendingAddOnsFromExisting: PendingAddOn[] = existingAddOns.map((addOn) => ({
        ...addOn,
        _id: addOn._id // Keep the _id so we know these are existing add-ons
      }));
      setPendingAddOns(pendingAddOnsFromExisting);
      hasPopulatedAddOns.current = true;
    }
  }, [existingAddOns]);

  const handleCategoryChange = (values: string[]) => {
    setSelectedCategories(values);
    const newSubCategories = values.includes(`${musicCategories}`) ? musicSubCategories : photoSubCategories;
    setSubCategories(newSubCategories);
    setSelectedSubCategories([newSubCategories[0]]);
  };

  const handleSubCategoryChange = (values: string[]) => {
    setSelectedSubCategories(values);
  };

  const handleAddAddOn = useCallback((addOn: PendingAddOn) => {
    setPendingAddOns((prev) => [...prev, addOn]);
  }, []);

  const handleRemoveAddOn = useCallback(
    (index: number) => {
      const addOnToRemove = pendingAddOns[index];

      // If it's an existing add-on (has _id), delete it from backend
      if (addOnToRemove._id) {
        deleteAddOnMutation.mutate(addOnToRemove._id, {
          onSuccess: () => {
            // Remove from local state after successful deletion
            setPendingAddOns((prev) => prev.filter((_, i) => i !== index));
            toast.success('Add-on deleted successfully');
          },
          onError: (error) => {
            console.error('Error deleting add-on:', error);
            toast.error('Failed to delete add-on');
          }
        });
      } else {
        // If it's a new add-on (no _id), just remove from local state
        setPendingAddOns((prev) => prev.filter((_, i) => i !== index));
      }
    },
    [pendingAddOns, deleteAddOnMutation]
  );

  const handleUpdateAddOn = useCallback(
    async (index: number, updatedAddOn: PendingAddOn) => {
      const existingAddOn = pendingAddOns[index];

      // If it's an existing add-on (has _id), update it in backend
      if (existingAddOn._id && updatedAddOn._id) {
        try {
          await updateAddOn(existingAddOn._id, updatedAddOn as any);
          // Update local state after successful update
          setPendingAddOns((prev) => prev.map((addOn, i) => (i === index ? updatedAddOn : addOn)));

          // Invalidate queries to refresh data
          await queryClient.invalidateQueries({ queryKey: ['addOn', existingAddOn._id] });
          await queryClient.invalidateQueries({ queryKey: ['addOns'] });
          if (itemId) {
            await queryClient.invalidateQueries({ queryKey: ['addOns', 'item', itemId] });
            await queryClient.invalidateQueries({ queryKey: ['item', itemId] });
            await queryClient.invalidateQueries({ queryKey: ['items', {}] });
          }

          toast.success('Add-on updated successfully');
        } catch (error) {
          console.error('Error updating add-on:', error);
          toast.error('Failed to update add-on');
        }
      } else {
        // If it's a new add-on, just update local state
        setPendingAddOns((prev) => prev.map((addOn, i) => (i === index ? updatedAddOn : addOn)));
      }
    },
    [pendingAddOns, queryClient, itemId]
  );

  const pricePerOptions = [
    { value: 'hour', label: t('form.pricePer.hour') },
    { value: 'session', label: t('form.pricePer.session') },
    { value: 'unit', label: t('form.pricePer.unit') },
    { value: 'song', label: t('form.pricePer.song') },
    { value: 'project', label: t('form.pricePer.project') },
    { value: 'day', label: t('form.pricePer.day') }
  ];

  // Use English values for options (what gets submitted)
  const pricePerValues = pricePerOptions.map((option) => option.value);

  // Helper to get display label for a value
  const getPricePerLabel = (value: string) => {
    const option = pricePerOptions.find((opt) => opt.value === value);
    return option ? option.label : value;
  };

  // Booking Settings custom content
  const bookingSettingsContent = useMemo(
    () => (
      <div className="booking-settings-step">
        <div className="booking-settings-step__section">
          <h3 className="booking-settings-step__section-title">
            {t('form.steps.bookingSettings')}
          </h3>
          <div className="booking-settings-step__grid">
            <DurationField
              name="minimumBookingDuration"
              label={t('form.bookingSettings.minimumBookingDuration.label')}
              description={t('form.bookingSettings.minimumBookingDuration.description')}
              value={minimumBookingDuration}
              onChange={setMinimumBookingDuration}
            />
            <DurationField
              name="maximumBookingDuration"
              label={t('form.bookingSettings.maximumBookingDuration.label')}
              description={t('form.bookingSettings.maximumBookingDuration.description')}
              value={maximumBookingDuration}
              onChange={setMaximumBookingDuration}
            />
          </div>

          {/* Only show minimumQuantity for non-hourly pricing */}
          {pricePer !== 'hour' && (
            <div className="booking-settings-step__field">
              <label className="booking-settings-step__label">
                {t('form.bookingSettings.minimumQuantity.label')}
              </label>
              <p className="booking-settings-step__description">
                {t('form.bookingSettings.minimumQuantity.description')}
              </p>
              <input
                type="number"
                name="minimumQuantity"
                value={minimumQuantity ?? ''}
                onChange={(e) => setMinimumQuantity(e.target.value ? Number(e.target.value) : undefined)}
                min={1}
                placeholder="1"
                className="booking-settings-step__input"
              />
            </div>
          )}

          <Field as="div" className="booking-settings-step__switch-group">
            <Switch
              checked={allowSameDayBooking}
              onChange={(checked) => {
                setAllowSameDayBooking(checked);
                // Clear advance booking required when same-day booking is enabled
                if (checked) {
                  setAdvanceBookingRequired({});
                }
              }}
              className={`booking-settings-step__switch ${allowSameDayBooking ? 'on' : ''}`}
            />
            <div className="booking-settings-step__switch-content">
              <Label className="booking-settings-step__switch-label">
                {t('form.bookingSettings.allowSameDayBooking.label')}
              </Label>
              <p className="booking-settings-step__switch-description">
                {t('form.bookingSettings.allowSameDayBooking.description')}
              </p>
            </div>
          </Field>

          <DurationField
            name="advanceBookingRequired"
            label={t('form.bookingSettings.advanceBookingRequired.label')}
            description={t('form.bookingSettings.advanceBookingRequired.description')}
            value={advanceBookingRequired}
            onChange={setAdvanceBookingRequired}
            unitOptions={['hours', 'days']}
            disabled={allowSameDayBooking}
          />
        </div>

        <div className="booking-settings-step__section">
          <h3 className="booking-settings-step__section-title">
            {t('form.bookingSettings.preparationTime.label')}
          </h3>
          <div className="booking-settings-step__grid">
            <DurationField
              name="preparationTime"
              label={t('form.bookingSettings.preparationTime.label')}
              description={t('form.bookingSettings.preparationTime.description')}
              value={preparationTime}
              onChange={setPreparationTime}
            />
            <DurationField
              name="bufferTime"
              label={t('form.bookingSettings.bufferTime.label')}
              description={t('form.bookingSettings.bufferTime.description')}
              value={bufferTime}
              onChange={setBufferTime}
            />
          </div>
        </div>
      </div>
    ),
    [
      t,
      pricePer,
      minimumBookingDuration,
      maximumBookingDuration,
      minimumQuantity,
      advanceBookingRequired,
      preparationTime,
      bufferTime,
      allowSameDayBooking
    ]
  );

  // Policies custom content
  const policiesContent = useMemo(
    () => (
      <div className="policies-step">
        <CancellationPolicyField
          value={cancellationPolicy}
          onChange={setCancellationPolicy}
        />
      </div>
    ),
    [cancellationPolicy]
  );

  // Define form steps with Zod schemas
  const steps: FormStep[] = useMemo(
    () => [
      {
        id: 'basic-info',
        title: t('form.steps.basicInfo') || 'Basic Information',
        description: t('form.steps.basicInfoDesc') || 'Enter your item name and description',
        fieldNames: ['name.en', 'name.he', 'description.en', 'description.he', 'languageToggle'],
        schema: itemStepSchemasEdit['basic-info'],
        languageToggle: true
      },
      {
        id: 'categories',
        title: t('form.steps.categories') || 'Categories',
        description: t('form.steps.categoriesDesc') || 'Select categories and subcategories',
        fieldNames: ['categories', 'subCategories'],
        schema: itemStepSchemasEdit.categories
      },
      {
        id: 'pricing',
        title: t('form.steps.pricing') || 'Pricing & Options',
        description: t('form.steps.pricingDesc') || 'Set price and booking options',
        fieldNames: ['price', 'pricePer', 'instantBook'],
        schema: itemStepSchemasEdit.pricing
      },
      {
        id: 'booking-settings',
        title: t('form.steps.bookingSettings') || 'Booking Settings',
        description: t('form.steps.bookingSettingsDesc') || 'Set booking rules and preparation times',
        fieldNames: [
          'minimumBookingDuration',
          'maximumBookingDuration',
          'minimumQuantity',
          'advanceBookingRequired',
          'preparationTime',
          'bufferTime',
          'allowSameDayBooking'
        ],
        schema: itemStepSchemasEdit['booking-settings'],
        customContent: bookingSettingsContent
      },
      {
        id: 'policies',
        title: t('form.steps.policies') || 'Policies',
        description: t('form.steps.policiesDesc') || 'Define cancellation and booking policies',
        fieldNames: ['cancellationPolicy'],
        schema: itemStepSchemasEdit.policies,
        customContent: policiesContent
      },
      ...(isFeatureEnabled('addOns')
        ? [
            {
              id: 'add-ons',
              title: t('form.steps.addOns') || 'Add-Ons',
              description: t('form.steps.addOnsDesc') || 'Add optional add-ons to your item',
              fieldNames: [],
              schema: itemStepSchemasEdit['add-ons'],
              customContent: (
                <CreateAddOnForm
                  mode="local"
                  onAdd={handleAddAddOn}
                  onRemove={handleRemoveAddOn}
                  onUpdate={handleUpdateAddOn}
                  pendingAddOns={pendingAddOns}
                />
              )
            }
          ]
        : [])
    ],
    [t, pendingAddOns, handleAddAddOn, handleRemoveAddOn, handleUpdateAddOn, bookingSettingsContent, policiesContent]
  );

  // Initialize currentStepIndex from URL on mount
  const [currentStepIndex, setCurrentStepIndex] = useState(0);

  // Initialize and sync currentStepIndex with URL
  useEffect(() => {
    const urlStepIndex = getStepFromUrl(searchParams, steps);
    setCurrentStepIndex(urlStepIndex);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  // Reset language when step changes
  useEffect(() => {
    setSelectedLanguage('en');
  }, [currentStepIndex]);

  const fields = [
    {
      name: 'name.en',
      label: `${t('form.name.en')} ðŸ‡ºðŸ‡¸`,
      type: 'text' as FieldType,
      value: item?.name.en
    },
    {
      name: 'name.he',
      label: `${t('form.name.he')} ðŸ‡®ðŸ‡±`,
      type: 'text' as FieldType,
      value: item?.name.he
    },
    {
      name: 'description.en',
      label: `${t('form.description.en')} ðŸ‡ºðŸ‡¸`,
      type: 'textarea' as FieldType,
      value: item?.description?.en
    },
    {
      name: 'description.he',
      label: `${t('form.description.he')} ðŸ‡®ðŸ‡±`,
      type: 'textarea' as FieldType,
      value: item?.description?.he
    },
    {
      name: 'languageToggle',
      label: t('form.languageToggle.label') || 'Select language for editing',
      type: 'languageToggle' as FieldType,
      value: selectedLanguage,
      onChange: setSelectedLanguage
    },
    {
      name: 'categories',
      label: t('form.categories.label'),
      type: 'select' as FieldType,
      options: [musicCategories, photoCategories],
      value: selectedCategories,
      onChange: handleCategoryChange
    },
    {
      name: 'subCategories',
      label: t('form.subCategories.label') || 'Sub Categories',
      type: 'multiSelect' as FieldType,
      options: subCategories,
      value: selectedSubCategories,
      onChange: handleSubCategoryChange,
      initialVisibleCount: 12,
      showAllLabel: t('form.subCategories.showAll', 'Show All'),
      showLessLabel: t('form.subCategories.showLess', 'Show Less'),
      className: 'subcategories-plain'
    },
    {
      name: 'price',
      label: t('form.price.label'),
      type: 'number' as FieldType,
      value: item?.price
    },
    {
      name: 'pricePer',
      label: t('form.pricePer.label'),
      type: 'select' as FieldType,
      options: pricePerValues,
      value: pricePer,
      displayValue: getPricePerLabel(pricePer),
      getOptionLabel: getPricePerLabel,
      onChange: (value: string) => setPricePer(value)
    },
    {
      name: 'instantBook',
      label: t('form.instantBook.label'),
      type: 'checkbox' as FieldType,
      value: item?.instantBook || false
    }
  ];

  const handleSubmit = async (formData: ItemFormData) => {
    formData.imageUrl = imageUrl;
    formData.categories = selectedCategories;
    formData.subCategories = selectedSubCategories;
    formData.studioId = item?.studioId || '';
    formData.pricePer = pricePer;
    // Convert string to boolean for instantBook (SteppedForm passes checkbox values as strings)
    formData.instantBook = formData.instantBook === 'true' || formData.instantBook === true;

    // Extract city from studio if item.city is not available
    if (!formData.city && !item?.city) {
      formData.city = studio?.city || '';
    } else if (!formData.city) {
      formData.city = item?.city || '';
    }

    // Ensure name and description objects are preserved
    formData.name = {
      en: formData.name?.en || item?.name?.en || '',
      he: formData.name?.he || item?.name?.he || ''
    };

    formData.description = {
      en: formData.description?.en || item?.description?.en || '',
      he: formData.description?.he || item?.description?.he || ''
    };

    // Add booking settings (only include if they have values)
    if (minimumBookingDuration.value && minimumBookingDuration.unit) {
      formData.minimumBookingDuration = minimumBookingDuration;
    }
    if (maximumBookingDuration.value && maximumBookingDuration.unit) {
      formData.maximumBookingDuration = maximumBookingDuration;
    }
    if (minimumQuantity !== undefined && minimumQuantity > 0) {
      formData.minimumQuantity = minimumQuantity;
    }
    if (advanceBookingRequired.value && advanceBookingRequired.unit) {
      formData.advanceBookingRequired = advanceBookingRequired;
    }
    if (preparationTime.value && preparationTime.unit) {
      formData.preparationTime = preparationTime;
    }
    if (bufferTime.value && bufferTime.unit) {
      formData.bufferTime = bufferTime;
    }
    formData.allowSameDayBooking = allowSameDayBooking;

    // Add cancellation policy (only include if type is selected)
    if (cancellationPolicy.type) {
      formData.cancellationPolicy = cancellationPolicy;
    }

    // Remove UI-only fields that shouldn't be sent to the API
    delete formData.languageToggle;

    // Update item first, then batch create new add-ons (only ones without _id)
    updateItemMutation.mutate(formData as Item, {
      onSuccess: async () => {
        // Filter to only new add-ons (without _id) for batch creation
        const newAddOns = pendingAddOns.filter((addOn) => !addOn._id);

        if (newAddOns.length > 0 && itemId) {
          try {
            await createAddOnsBatch(itemId, newAddOns);
            toast.success(`Item updated and ${newAddOns.length} add-on(s) created successfully`);
            // Remove created add-ons from pending list, keep existing ones
            setPendingAddOns((prev) => prev.filter((addOn) => addOn._id));
          } catch (error) {
            console.error('Error creating add-ons:', error);
            toast.error('Item updated but failed to create some add-ons. Please add them manually.');
          }
        } else if (pendingAddOns.length > 0) {
          // All add-ons are existing ones, just show success
          toast.success('Item updated successfully');
        }
        // Invalidate addOns queries
        if (itemId) {
          await queryClient.invalidateQueries({ queryKey: ['addOns', 'item', itemId] });
        }
        await queryClient.invalidateQueries({ queryKey: ['addOns'] });
      }
    });
  };

  // Guard: Don't render form until item data is loaded
  // Must be after all hooks to maintain hook order
  if (!item) {
    return <div>Loading...</div>;
  }

  return (
    <section>
      <section className="form-wrapper edit-item-form-wrapper">
        <SteppedForm
          className="edit-item-form"
          formId="edit-item-form"
          steps={steps}
          fields={fields}
          onSubmit={handleSubmit}
          onCategoryChange={handleCategoryChange}
          submitButtonText={t('form.submit.editItem')}
          nextButtonText={t('form.buttons.next') || 'Next'}
          previousButtonText={t('form.buttons.previous') || 'Previous'}
          selectedLanguage={selectedLanguage}
          onLanguageChange={setSelectedLanguage}
          onStepChange={(current) => setCurrentStepIndex(current)}
        />
      </section>
    </section>
  );
};
